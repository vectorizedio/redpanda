- Feature Name: centralized configuration management
- Status: in-progress
- Start Date: 2021-01-10
- Authors:
- Issue: (one or more # from the issue tracker)

# Executive Summary

Currently we configure redpanda brokers using old-fashioned configuration files
residing on each node. This approach makes certain day-two operations complicated
and error prone. One of such examples would be changing the default topic
replication factor. With current approach in order to change the default
replication factor, one have to edit configuration file on each node and then do
the cluster rolling restart. It is very important to set the correct (the same)
value on each of the nodes as a simple typo may lead to undefined behavior.

## What is being proposed

Since redpanda is de-facto a database building block (WAL), we can leverage that
fact and build simple distributed key value store to handle global cluster
configuration. Configuration properties that are required only locally and are
different for each node like f.e. listen_address or node id would be stored in
an existing `storage::kvstore`.

## Why (short reason)

Storing configuration globally would allow user to simplify cluster management.
User will be able to change configuration by both the RPK and simple web page
embedded and served by redpanda. Additionally configuration value will be
coherent across the cluster nodes. What is also worth mentioning is the support
for changing some of the configuration parameters in runtime -
feature that isn't currently supported by redpanda.

## What is the expected outcome?

After the proposed change will be applied we except redpanda to be easily
configurable with one or all of the following:

- `redpanda` binary command line arguments
- environment variables
- `rpk` command
- REST api exposed by each broker

All global configuration properties should be changeable from each node.

# Reference-level explanation
## Top level design

Configuration is a map of configuration properties. Configuration interface
should allow accessing configuration properties from each core. After redpanda
starts it hydrates configuration properties from different sources.
Command line arguments always take precedence. After first start redpanda will
no longer require passing basic parameters as command line arguments as all
configuration properties will be stored internally. All configuration parameters
have default values so it should be possible to start redpanda without
passing any command line arguments.

In real life scenario starting the broker should require the following:

```bash
  # node 1
  redpanda --node-id=1 --data-directory=/var/lib/redpanda

  # node 2
  redpanda --node-id=2 --data-directory=/var/lib/redpanda --seed-servers=192.168.0.1:31548
```

### Command line flags

Redpanda supports changing configuration property values via command line flags.
Command lines flags are automatically generated by configuration library as a
`boost::program_options::option_descriptions`. Using boost program options library
allow simple integration with Seastar application.

Command line flags examples:

```bash
    --data-directory /var/lib/redpanda
    --rpc-server localhost:31245
```

#### Aggregates

In order to make redpanda easy to use and configure and at the same time do not
add a lot of programmatic overhead the proposed way to express aggregates is to
either define simple human readable representation of an aggregate f.e.

```c++
struct unresolved_address {
    uint16_t port;
    ss::sstring address;
};
```

can be expressed as `<host>:<port>` string, or split the aggregate into separate
primitive data types.

One of the candidates that may benefit from splitting is the `tls_config` 
structure.

```c++
struct key_cert {
    ss::sstring key_file;
    ss::sstring cert_file;
};

class tls_config {
public:
   ...
private:
    bool _enabled{false};
    std::optional<key_cert> _key_cert;
    std::optional<ss::sstring> _truststore_file;
    bool _require_client_auth{false};
};
```

For the `tls_config` it is much more convenient to split it into separate
independent properties f.e:

`rpc_tls_key`, `rpc_tls_cert`, `rcp_tls_truststore`, ...

#### Environment variables

All command line flags values can be set via environment variables.
Name of environment variables are always capitalized and words separated with
underscore character. All environment variables are prefixed with `REDPANDA_`
prefix. Command line arguments passed to redpanda takes precedence over
environment variables if both are set.

Example configuration flags and corresponding environment variables:

`--data-directory` `REDPANDA_DATA_DIRECTORY`
`--heartbeat-interval-ms` `REDPANDA_HEARTBEAT_INTERVAL_MS`

#### Collections

For command line variables collections of parameters is set by passing
in the same flag more than once or pass comma separated list of values.
f.e:

```bash
redpanda --seed-server 127.0.0.1:1234 --seed-server 127.0.0.1:4321

redpanda --seed-server 127.0.0.1:1234, 127.0.0.1:4321
```

For environment variable collections will always be passed as a comma separated 
list f.e.:

```bash
REDPANDA_SEED_SERVERS= 127.0.0.1:1234,127.0.0.1:4321
```

#### Named listeners

For the named listener properties we are going to use approach similar to the
one used in Kafka. Named listeners will use the URI like representation where
protocol schema is used as a listener name.

```bash
    <name>://<address>:<port>
```

This way we can define listeners list as:

```bash
KAFKA_API=INTERNAL://10.48.0.123:9092,EXTERNAL://87.54.17.98:9092
```

## Configuration property value

Redpanda supports multiple sources for values of configuration properties.
The configuration property precedence policy clearly defines what would be the
final value of a configuration property if its value is different in each source.
Redpanda defines a simple policy for configuration properties value precedence,
as property value is always equal to the one persisted in configuration storage.
Configuration storage works according to the 'Last write wins' rule.
This way, the most recent value set is used.
When redpanda is started with set of flags or environment variables value of
properties set with flags are persisted and stored values are overridden.
If configuration change will be propagated to running redpanda instance later on
it will override stored configuration value.
This way redpanda always treat stored configuration as a source of truth.

### Features of configuration properties

Configuration properties may have different features.
Redpanda configuration properties may be described by set of features.
Those features determine policy of updates, persistance and programmatic API of
the configuration properties.

#### Scope

Feature describing property range and the at the same time persistence policy.

Possible values: `node/cluster`

- `node` -  properties concern only single node
- `cluster` - cluster properties will eventually have the same value on all the 
              nodes, once set are propagated to all the nodes

#### Change policy

Possible values: `runtime/restart/invariant`

- `invariant` - if property is invariant it can not be changed
                without pruning node data, changing `invariant` property will
                stop redpanda from starting

- `runtime` - runtime changeable properties are the one that when updated are
              immediately visible to all dependent components, they may change
              in any point in time

- `restart` - properties which require restart for the change to applied.
              In future we may have less and less of this properties as we make
              more features runtime configurable

Example features of currently existing redpanda properties:

`node_id` - local,invariant
`developer_mode` - local,restart
`rpc_server` - local,restart
`raft_heartbeat_interval_ms` - global,runtime
`data_directory` - local,invariant

### Configuration properties persistance

Once set the configuration property is stored in a `config::kvstore` either
local `storage::kvstore` or `cluster::kvstore` is used based on the property
`scope` feature. Accessing and changing configuration property values will be
exactly the same for both types of storages, for the user it the property API 
will be storage type agnostic.

#### Local configuration persistance - `scope::node`

Local configuration persistance is based on the `storage::kvstore`. Knowing the
limitation of `storage::kvstore` and the main purpose it was designed for
(i.e. persisting raft state) we can safely assume that configuration operation
will not exceed its capacity. Configuration changes are rare and the amount of
local configuration properties is limited. In order to be able to access the
`storage::kvstore` before any other redpanda services starts, configuration
has its own `storage::kvstore` instance.

#### Replicated key value store - `scope::cluster`

Cluster wide configuration properties are stored in simple replicated key value
store based on `raft-0` log. The distributed kv-store that backs up global
configuration will work in a similar way to `storage::kvstore`, but instead of
storing data in local `storage::log` it will use `raft-0` partition to replicate
data. KV-store implementation will be realized as a simple FSM.
All properties are cached in memory in a form of
`absl::flat_hash_map<iobuf,iobuf>`. The distributed KV-store will use existing
serialization library to serialize configuration properties.

### Circular dependencies

Since configuration module is going to use other modules, i.e. storage and
cluster, to persist configuration properties it would have to depend on those
modules. On the other hand those module have to depend on configuration module
since both storage and cluster module access configuration properties.
In order to overcome this issue configuration module will use generic
template types which are going to be specified in `application.cc` this
way we prevent circular dependencies.

### Versioning

Configuration class wouldn't as a whole wouldn't need versioning. For parameters
that were added and are not preset in persistence Redpanda will use the default
value. Value of properties that were removed will be simply ignored.
For versioning of an individual aggregates we will rely on versioning support
embedded in our next gen serialization library.

### Code generation

Configuration classes with properties definitions are code generated basing on
a simple JSON file. The file defines list of properties with basic validations.
Validators are functions predefined in configuration library.

Example configuration definition:

```json
{
    "namespace": "config",
    "name": "configuration",
    "properties": [
        {
            "name": "data_directory",
            "type": "string",
            "scope": "node",
            "description": "directory where Redpanda writes data",
            "long_description": "longer form, suitable to be used in docs",
            "change_policy": "invariant", 
            "validators": [{"type": "path"}]
        },
        {
            "name": "rpc_listener",
            "type": "unresolved_address",
            "scope": "node",
            "description": "address of RPC inter node protocol listener",
            "long_description": "longer form, suitable to be used in docs",
            "change_policy": "restart",
            "validators": [{"type": "listener_address"}]
        },
        {
            "name": "heartbeat_interval_ms",
            "type": "duration",
            "scope": "cluster",
            "description": "interval between heartbeats",
            "long_description": "longer form, suitable to be used in docs",
            "change_policy": "runtime",
            "validators": [{"type": "range", "min": 1, "max": 100000}]
        }
    ]
}
```

Generator will use JSON schema to make sure that configuration definition is
valid. In the first implementation the code generator will output `.h` and
`.cc` files defining the configuration class. Generator will also generate
scaffold for documentation that will be used in documentation web page. This way
we will have a single source of truth, describing configuration options.

### REST Api

Redpanda will define following set of resources (defined in `openapi: 3.0.0`)

```yaml
openapi: 3.0.0
info:
  title: Redpanda configuration API
  version: 1.0.0
paths:
  /configuration_schema:
    get: 
      summary: Returns all available configuration options with schemas
      responses:
        '200':
          description: JSON defintion of all redpanda options
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/config_schema'
      
  /configuration:
    get:
      summary: Returns redpanda configuration map.
      responses:
        '200':    # status code
          description: A JSON representation of redpanda configuration
          content:
            application/json:
              schema: 
                type: object
                additionalProperties: {}
  /configuration/{property_name}:
    get:
      summary: Returns single property value
      parameters:
        - in: path
          name: property_name
          schema:
            type: string
          required: true
          description: Property name
      responses:
        '200':
          description: JSON representation of given redpanda property
          content:
            application/json:
              schema: 
                type: object
    post:
      summary: Sets property value
      parameters:
        - in: path
          name: property_name
          schema:
            type: string
          required: true
          description: Property 
      requestBody:
        description: Property value
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        '200':
          description: value set succesfully
        

components:
  schemas:
    property_schema:
      type: object
      properties:
        name: 
          type: string
        scope:
          type: string
          enum: ['cluster','node']
        type:
          type: string
        change_policy:
          enum: ['invariant', 'restart', 'runtime']
        
    config_schema:
      type: object
      properties:
        properties:
          type: array
          items: 
            $ref: '#/components/schemas/property_schema'
        types:
          description: list of custom type definitions in openapi 3.0 schema format
          type: array
          items: 
            type: object
```

In order to list available properties RPK or web interface will have to query
`configuration_schema` path and parse provided output. This approach will allow
us not to update RPK and dashboard configuration definitions every time redpanda
configuration will change.

## Low level design

### Configuration class

The `config::config_store` is a base class for all configuration representing
classes it expose basic interface to interact with configuration properties.

### `kvstore` interface

`config::kvstore` is an interface providing common abstraction layer for local
and distributed configuration persistance. Additionally the `config::kvstore`
will encapsulate logic of cross shard communication.

```c++
class kvstore {
public:
    using foreign_iobuf_t = ss::foreign_ptr<std::unique_ptr<iobuf>>;
    struct kv_tuple {
        kv_tuple(ss::sstring key, iobuf value) noexcept
          : _key(std::move(key))
          , _value(
              ss::make_foreign(std::make_unique<iobuf>(std::move(value)))) {}

        kv_tuple(const kv_tuple& other) noexcept
          : _key(other._key)
          , _value(
              ss::make_foreign(std::make_unique<iobuf>(other._value->copy()))) {
        }

        kv_tuple(kv_tuple&&) noexcept = default;
        kv_tuple& operator=(kv_tuple&&) noexcept = default;
        kv_tuple& operator=(const kv_tuple& other) noexcept {
            if (this == &other) {
                return *this;
            }
            new (this) kv_tuple(other);
            return *this;
        };
        ~kv_tuple() = default;
        iobuf release_value() && { return std::move(*_value.get()); }
        const ss::sstring& key() const { return _key; }

    private:
        ss::sstring _key;
        foreign_iobuf_t _value;
    };

    struct impl {
        virtual ss::future<std::vector<kv_tuple>> wait_for_changes() = 0;
        virtual ss::future<std::optional<foreign_iobuf_t>>
          get(std::string_view) = 0;
        virtual ss::future<> set(std::string_view, iobuf&&) = 0;
        virtual ~impl() = default;
    };

    ss::future<std::vector<kv_tuple>> wait_for_changes() {
        return _impl->wait_for_changes();
    }

    ss::future<> set(std::string_view key, iobuf&& value) {
        return _impl->set(key, std::move(value));
    }

    ss::future<std::optional<foreign_iobuf_t>> get(std::string_view key) {
        return _impl->get(key);
    }

    template<typename Impl, typename... Args>
    static kvstore make_kvstore(Args&&... args) {
        return kvstore(std::make_unique<Impl>(std::forward<Args>(args)...));
    }

private:
    explicit kvstore(std::unique_ptr<impl> impl)
      : _impl(std::move(impl)) {}
    std::unique_ptr<impl> _impl;
};
```

## Configuration library API

Application configuration inherits the `config::config_store` class.
Configuration properties are defined as configuration class fields.

Example (using definition from previous section): 

```c++

class configuration : public config_store<configuration>{

    property<ss::sstring, scope::node, change_policy::invariant, configuration>
        data_directory;

    property<unresolved_address, scope::node, change_policy::restart, configuration>
        rpc_listener;

    property<std::chrono::milliseconds, scope::cluster, change_policy::runtime, configuration>
        heartbeat_interval_ms;

};
{
    "namespace": "config",
    "name": "configuration",
    "properties": [
        {
            "name": "data_directory",
            "type": "string",
            "scope": "node",
            "change_policy": "invariant", 
            "validators": [{"type": "path"}]
        },
        {
            "name": "rpc_listener",
            "type": "unresolved_address",
            "scope": "node",
            "change_policy": "restart",
            "validators": [{"type": "listener_address"}]
        },
        {
            "name": "heartbeat_interval_ms",
            "type": "duration",
            "scope": "cluster",
            "change_policy": "runtime",
            "validators": [{"type": "range", "min": 1, "max": 100000}]
        }
    ]
}
```

### Configuration access interface

### Fitting configuration into Seastar thread per core shared nothing architecture

Configuration properties have to be accessible on every core, additionally when
components are going to subscribe for configuration property changes it will be
more efficient and simpler to avoid cross core communication. On the other hand
all configuration updates will happen on a single core and additionally in order
to persist configuration, values have to be routed to core 0.
In order to simplify accessing configuration all updates will be automatically
propagated to all shards by `config::config_store` class. It is leveraging
`seastar::peered_shared_service` to communicate with instances on other cores.
Values are copied on each core and cached in `config::property<...>` instances.

## Interaction with other features

Additional features have to be implemented in following parts of Vectorized
software stack:

- RPK - we have to implement HTTP client that will interact with redpanda HTTP
        admin API to manage configuration, it would be also good to implement
        feature allowing extracting configuration from controller log segment
        files. This would allow us to debug clusters during critical failure.

- HTTP dashboard - implementing UI to navigate and  manage redpanda configuration.

## Telemetry & Observability

In order to be able to validate and read configuration while cluster is being
offline we will add a tool to RPK to read configuration using configuration
log segment files.

Additional metrics for configuration change rate and configuration change.
errors will be added.

## Corner cases dissected by example

One of the corner cases is setting the list of seed servers  and initialization
of a new cluster. Right now seed server property may be different on each node.

In order to simplify redpanda deployment it would be ideal if all of the nodes
may accept the same list of seed servers.

## Drawbacks

The main drawback of proposed approach is an increased complexity of proposed
solution comparing to simple configuration file. The increased complexity is
however compensated with ease of management. User experience is one of the top
priorities hence we should pay cost of increased complexity.

## Rationale and Alternatives

One of the alternatives would be to use external configuration store like
Consul/Zookeeper/Etcd. This approach has one major drawback as it makes redpanda
installation/operations more complicated.

## Unresolved questions

- Do we want to change node specific configurations from each node ?
- Do we want to support authentication/authorization for configuration
  management operation ?
- Do we want to reuse configuration in Panda Proxy ?
- Do we want to populate configuration via environment variable ?
